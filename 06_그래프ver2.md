# 완전 그래프 
> (V * V-1)/2
> 단 당방향일 경우에 `/2`이다.
   
정점들에 대해 가능한 모든 간선들을 가진 그래프 

# 부분 그래프  
원래 그래프에서 일부의 정점이나 간선을 제외한 그래프 

# 트리는 싸이클이 없는 무향 연결 그래프이다.  
* 두 노드 사이에는 유일한 경로가 존재한다.  
* 각 노드는 최대 하나의 부모 노드가 존재할 수 있다.  
* 각 노드는 자식 노드가 없거나 하나 이상이 존재할 수 있다.  

# 인접 
* 두 개 정점에 간선이 존재하면 서로 `인접`해있다고 한다. (두 노드가 연결되어 있다면)  
* 완전 그래프에 속한 임의의 두 정점들은 모두 인접해 있다.   

# 경로 
경로란 어떤 정점에서 시작하여   
다른 정점로 끝나는 순회로 두 정점 사이를 잇는 간선들을 **순서대로 나열한 것**  
  
* 0-6  
* 정점들 0-2-4-6 
* 간선들 (0,2)(2,4)(4,6)   
  
경로중 한 정점을 최대 한 번만 지나는 경로를 단순경로라고 한다.     
`0-2-4-6`, `0-1-6`       
대개 이런 문제들은 최소 비용 경로, 최소 노드를 지나는 경로를 구하는 문제로 많이 출제된다.     
          
**순환경로**         
* 흔히 `싸이클`이라고 표현하기도 한다.    
* 노드의 갯수를 따지지 않고 경로의 시작점과 끝점이 같은 것을 의미한다.  
* 경로에서 어떤 정점을 `2`번 이상 거치는 경우 
* 1-3-5-1  
* 1-2-1 또한 사이클이다

# 간선 정보  
## 인접 행렬 
> 노드의 정점을 중심으로 탐색한다.
   
* `V * V` 크기의 2차원 배열을 이용해서 간선 정보를 저장 
* 배열의 배열 
    
## 인접 리스트 
> 노드의 정점을 중심으로 탐색한다.  
>   
* 각 정점마다 다른 정점으로 나가는 간선의 정보를 저장한다.     

## 간섭리스트
> 크루스칼 알고리즘에서 사용 
> 최소 간선만 먼저 찾아서 진행한다.  

* 간선의 정보를 객체로 표현하여 리스트에 저장  

# 인접 행렬 
> 두 정점을 연결하는 간선의 `유무`를 행렬로 표현   
> 대개, 연결되어 있지 않은 간선은 `0`으로 표현한다.

* V x V 정방 행렬 
* 행 번호와 열 번호는 그래프의 정점에 대응 
* 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현  

**무향 그래프** 
* i 번째 행의 합 = i번째 열의 합 = ㅍV의 차수  

**유향 그래프**
* 행 i의 합 - Vi의 진출 차수 
* 열 i의 합 - Vi의 진입 차수 

즉, 가로에 있는 0이 아닌 수가 나가는 간선
세로에 있는 0이 아닌 수가 들어오는 간선  

**인접 행렬의 단점은?**    
`희소 그래프` VS `밀집 그래프`     

* 희소 그래프 :   
  * 정점은 상대적으로 많고, 간선은 적은 경우   
  * 간선의 수가 적지만 정점이 많기에 `V*V`의 크기를 만들어야한다
   
알고리즘 메모리 제한은 주로, 256/512 로 주어진다.     
그렇기에 많은 정점을 기준으로 2차원 배열을 만들면? 메모리 초과가 될 확률이 높다.   
또한, 배열의 크기 + 연산시 사용되는 메모리도 있으니 사용하기는 좋지 않다.  


* 밀집 그래프 : 
  * 정점 간선 비례해서 많은 경우
  * 간선이 많아도 희소그래프처럼 모든 탐색을 진행하기에 공간만 가능한지 확인하면 된다.  

정리하자면 희소그래프 때는 굳이 인접행렬로 할 필요가 없다.  
그렇기 때문에 인접리스트로 문제를 풀자  
  
# 인접 리스트   
   
각 정점에 대한 인접 정점들을 순차적으로 표현        
하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장     
이때, 연결 목록 유지를 위한 포인터(링크)가 있다.(관계성 X)    
       
ArrayList와 같은 컬렉션을 사용한다면, 속도나 메모리가 조금 오바될 수 있는데       
이를 `커스텀 Node`로 만들어 직접 구현하면 어떤 경우는 `30%`까지 절약할 수 도 있다.   
그리고 이러한 경우가 가능한 것은 순서가 상관없기 때문이다.  

**무향 그래프** 
* 노드 수 : 간선의 수 *2 (A->B, B->A)  
* 각 정점의 노드수 = 정점의 차수 

**방향 그래프**
* 노드 수 : 간선의 수 (A -> B)   
* 각 정점의 노드 수 = 정점의 차수 
  
# 간선 리스트 
두 정점에 대한 간선 그 자체를 객체로 쵸현하여 리스트를 저장
간선을 표현하는 두 정점 정보를 나타냄 

# 그래프 탐색 
그래프 순회는 비선형구조인 그래프로 표현된 모든 자료를 빠짐없이 탐색하는 것을 의미한다.   

1. BFS
2. DFS

## BFS
너비우선탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 한 차례로 방문한 후에,    
방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식       
  
인접한 정점들에 대해 탐색을 한후,  
차례로 다시 너비우선탐색을 진행해야하므로, 선입선출 형태의 자료구조인 큐를 활용한다.   

### 초기상태   
* Visited 배열 생성 및 false로 초기화  
* Queue 생성
* 시작 정점 방문처리 및 enqueue  

### 입력 파라미터 `그래프 G`와 탐색 시작 `정점 V`
```java
BFS(G, v) // 그래프 G와 탐색 시작 정점v
    큐 생성
    시장 정점 v를 큐에 삽입
    정점 v를 방문한 것으로 표시
    while(큐가 비어 있지 않은 경우) {
        t <- 큐의 첫 번째 원소 반환
        for (t와 연결된 모든 간선에 대해) {
            u <- t의 인접 정점
            u가 방문되지 않은 곳이면, 
            u를 큐에 넣고, 방문한 곳으로 표시 
        }
    
    }
END BFS      
```  

 
 



































 
   

