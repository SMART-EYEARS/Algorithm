# 재귀    
재귀란 메서드 **자기 자신을 호출하는 것을 의미**한다.            
자신의 메서드를 타고 가기 때문에, 로직은 동일하지만               
메서드에 들어가는 **매개변수의 값이 변경되면서 로직을 수행**한다.     
              
여기서 중요한 점은 자기 자신을 호출하는 것과 매개변수의 값이다.                
**재귀**를 진행하면 언젠가 **탈출해야하는 조건, 즉 기저조건이 필요하다.**              
그리고 이러한 **기저조건은 변화되는 값, 매개변수를 이용해야한다.**          
물론, 상황에 따라서 전역변수를 이용하는 경우도 많지만        
우선 우리는 기저 조건을 이용해서 재귀를 탈출해야 한다.   
 
# 재귀 계획하기     
아래 3 단계는 일반적으로 알려진 재귀함수를 정의하는 방법이다.   
   
1. 메서드(함수)역할을 명확히 정의하라! (What)       
2. 메서드가 기능을 수행하기 위해 필요한 매개체 값(매개변수-> 결정 요인)   
3. 재귀의 끝 (기저조건)   
     
하지만, 필자의 경우 아래와 같은 프로세스를 따라 **더 효율적인 방법을 발견**했다.       
      
1. 우선 알맞는 기저 조건을 만든다.  
2. 예외 조건을 만든다.     
3. 두 조건을 생각해서 파라미터를 만든다.  
4. 상황에 따라서, 나오는 값이 항상 일정하고 재귀로 여러번 방문한다면 메모이제이션을 쓴다.  
5. 이후에는 정상 동작이니, 분기(반복문이나 조건문)에 따라 호출되는 재귀함수를 정의한다.         
      
이를 코드로 표현하면 아래와 같다.             
```java
public int go(int count, int n) {
    if(count == n) return 1;                              // 기저 조건
    if(count < 0 || count > n) return 0;                  // 예외 조건 
    if(d[count] != -1) return d[count];                   // 메모이제이션 
   
    // 여기서부터는 정상 동작 
   
    d[count] = 0;                                         // 초기값   
    for(어떤 조건){
        if(어떤조건){
            d[count] = Math.max(d[count], go(count+1, n);          
        }
    }
    return d[count];
}
```

# 반복 VS 재귀   
반복과 재귀는 그 형태가 매우 비슷하다.   
실제로 DP를 풀때는 아래와 같은 2가지 방법이 있다.       
  
* 반복문을 사용하는 Bottom-up 방식     
* 재귀를 사용하는 Top-down 방식   
     
하지만, 이 둘의 성능은 동일하다고 말을 할 수 없다.    
재귀를 이용하면 스택을 새로 생성해야하기에 스택오버플로우가 발생할 수 있고,     
반복문도 불필요한 반복문을 매번 탐색하는 경우도 있다.         
그렇기에 우리는 해결할 문제를 고려해서 반복이나 재귀 방법을 선택해야한다.        
            
* 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택             
* **재귀**는 문제 해결을 위한 **알고리즘 설계가 간단하고 자연스럽다.**             
* 특히, **Tree와 같은 추상 자료형의 알고리즘은 재귀적 구현이 간단하고 자연**스러운 경우가 많다.           
* 일반적으로, **재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산을 필요로 한다.**      
* 입력값 **n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.**       
      
||재귀|반복|
|-|---|----|
|종료|재귀 함수 호출이 종료되는 베이스 케이스|반복문의 종료 조건|
|수행 시간|상대적 느림|빠름|
|메모리 공간|많이 사용|적게 사용|
|소스 코드 길이|짧고 간결|길다|
|소스 코드 형태|선택 구조|반복 구조|
|무한 반복 시|스택 오버플로우|cpu를 반복해서 점유|


# 문제를 통해 알아보기   
## 피보나치

```c++
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-2);
  }
}
```

* f0 = 0   
* f1 = 1   
* fn = fn-1 + fn-2 (n >= 2)  

```c++
0,1,1,2,3,5,8,13,21,34,55....
```

* 문제 : N번째 피보나치 수를 구하는 문제  
* 작은 문제 : N-1 번째 피보나치 수를 구하는 문제, N-2 번째 피보나치 수를 구하는 문제 
* 위 같은 동작이 마지막 까지 반복....

큰 문제와 작은 문제는 상대적이다.      
문제를 작은 문제로 쪼갬으로 같은 형식의 구조를 취하고 있으니     
**큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.**    
   
**하지만,**     
같은 인풋을 주면, 같은 아웃풋이 나오는 코드가 너무 많다.     
즉, 이미 한 번 계산한 경험이 있지만, 중복해서 계산하는 코드가 많다.    
더불어 인풋값만 이용하지, 랜덤이나 다른 값을 이용하는 코드가 전혀 없다.   
즉 같은 인풋이면 같은 아웃풋을 보장하는 코드가 중복되서 일어난다.  
(**인풋에만 의존하는 코드가 아니면 아웃풋이 다를 수 있지만, 위 예시는 아니다.**)        

그렇기에 이를 조금 더 해결하고자 [Memoization](#memoization)을 이용한다.   

```c++
int memo[100];
int fibonacci(int n){
  if(n <= 1) {
    return n;
  } else {
    if(memo[n] > 0){ // 여기서 0은 아직 값을 넣지 않았다는 뜻
      return memo[n];
    }
    memo[n] = fibonacci(n-1) + fibonacci(n-2); 
    return memo[n];
  }
}
```

참고로 재귀를 위한 조건은 2가지 상황으로 구분된다.  
  
1. 재귀를 태운다음 거기서 탈출
2. 조건을 검사한 후 재귀를 태움
  
단, 이것은 개발자의 성향이며 자신에게 맞는 작업을 해주면 된다.     


## 하노이 타워  

```java
/*
	N : 원판의 개수
	start : 출발지
	mid : 옮기기 위해 이동해야 장소
	to : 목적지
*/
 
void Hanoi(int N, int start, int mid, int to) {
 
	// 이동할 원반의 수가 1개라면?
	if (N == 1) {
		print(start + " " + to + "\n");
		return;
	} 
    
	// STEP 1 : N-1개를 A에서 B로 이동
	Hanoi(N - 1, start, to, mid);
    
	// STEP 2 : 1개를 A에서 C로 이동
	print(start + " " + to + "\n");
    
	// STEP 3 : N-1개를 B에서 C로 이동
	print(N - 1, mid, start, to);
	
}
```
재귀함수의 끝판왕이라 생각하면 된다.       
    
로직에 대해서는 설명을 하지 않고 가장 중요한 말을 하려고 한다.      
재귀 함수는 **Flat** 하게 생각해야 한다. 즉, 쉽게 생각해야 한다.     
           
재귀 함수는 여러 경로(경우의 수)로 나눠진다.                
그렇기 때문에 재귀를 일일히 따라가서 검사를 한다는 것은 매우 어렵다.                 
**Flat** 하게 생각해야 한다는 것은 딱 현재 위치의 로직만 따라간다는 것이다.       
   
하노이 타워를 예시로 하겠다.    
우선 기저 조건이 존재하고 `n == 1` 이면 알아서 탈출 될 것이다.   

  
하노이 탑에서 맨 위에 있는 n번째 원판은 아무런 방해 없이 목적지로 이동해야 한다.         
그렇다면 n-1 번째 원판들은 목적지가 아닌 임시 막대기로 이동해 있어야 한다.         
이후, n번째 원판이 목적지에 이동했으면, n-1번재 원판들은 그제서야 목적지로 이동시켜야 한다.     

이를 코드로 구현해보자    
```java
Hanoi(N - 1, start, to, mid);
```  
* n-1 번째 원판들을 중간으로 이동시킨다.  

```java
print(start + " " + to + "\n");
```
* n번째 원판을 목적지로 이동시킨다.  

```
print(N - 1, mid, start, to);
```   
* 목적지에 있는 `n-1` 원판을 목적지로 이동시킨다.   

이렇듯 재귀는 `어차피 알아서 돌겠지` 라는 마인드를 가지는 것이 중요하다.   
그리고 도중 문제가 생기면, 로직을 따라가기 보다는    
`기저조건`,` 예외조건`, `메모이제이션`, `호출조건`, `매개변수위치`등을 확인하는 것이 좋다.   
다시 한번 말하지만 `알아서 돌겠지`라는 **Flat 한 생각이 필요하다**   
      
하지만, 살면서 딱 한번? 정도는 따라가는 경험도 나쁘지는 않다. ㅎㅎ    









