# 순열 
> nPr      
   
순열이란 나열된 배열중 몇 개의 수를 뽑지만, 그 순서도에 따라 의미가 다르다.   
   
예시로 들자면, 123이라는 숫자가 있다.   

* 1, 2, 3
* 1, 3, 2
* 2, 1, 3
* 2, 3, 1
* 3, 1, 2
* 3, 2, 1
   
위 수들은 중복해서 조합되지만, 그 순서가 다르다.    
그렇기 때문에 서로 다른 경우의 수로 취급을 하고 이러한 방법을 순열이라 말한다.   
   
# 순열 경우의 수 구하기     
우선 순열에 대한 공식(점화식)을 한번 살펴보자      
```java
nPr = n * (n-1) *  ... * (n-r+1)
```
순열은 `n` 부터 시작해서 `r`의 갯수만큼 **내려가면서 곱**해주는 형식이다.       
팩토리얼과 비슷하지만, 팩토리얼처럼 곱셈이 내려가지만 `r`만큼만 내려간다 생각하면 된다.    
  
예를 들어 `3P2`라고 가정한다면 `(3 * 2)`의 값이 나온다.   
실생활로 예를 들어 그럼 `25`명이 있는 반에서 `4`명 뽑는다면?  
`25 * 24 * 23 * 22`의 결과값으로 `303,600` 이라는 값이 나온다.            
    
```java   
nPr = n * (n-1) *  ... * (n-n+1)  
```  
그렇기 때문에 만약, r이 n이랑 같다면 `n!` 팩토리얼이라는 값이 나온다.      
              
# 순열이 이루어진 배열의 값 구하기       
사실, 대부분의 순열 문제는 우선 이 순열이 이루어진 배열의 값을 이용해야한다.    
다시 한번 말한다. **순열이 이루어진 배열을 활용해서 답을 도출해야한다.**      
순열이 이루어진 배열을 구했다해서 바로 답이 나오지는 않는다.       
그렇기 때문에 우리는 이 준비단계? 부터 완벽히 마스터해야 문제를 풀 수 있는 수준이 된다.     
  
배열을 만드는 방식은 여러가지가 존재한다.  
그 중에서 반복문을 사용해서 간단히 만들 수 있는 방법에 대해서 먼저 알아보도록 한다.   
  
## 재귀를 이용한 순열 배열 구하기  
### 중복 없는 순열
**케이스**   
```java
numbers[] : 순열 저장 배열 
isSelected[] : 인덱스에 해당하는 숫자가 사용 중인지 저장하는 배열  
perm(cnt) // cnt : 현재까지 뽑은 순열 수의 개수  
    if cnt == 3
        순열 생성 완료 
    else
        for i from 1 to 3
            if isSelected[i] == true -> continue;
            numbers[cnt] <- i
            isSelected[i] = true
            perm(cnt+1)
            isSelected[i] = false
        end_for
            
// 사실 numbers 도 초기화 해야하는데 반복 돌면서 덮어 씌워진다.            
// 여기서 중요한 것은 원소의 갯수 즉, 인덱스의 번호가 바뀌는게 중요하다
// 그렇기에 cnt+1의 작업을 한다.   
```
    
**실제 구현**   
```java
package com.ssafy.exhaustive;

import java.util.Arrays;

public class PermutationTest {
	static int[] numbers;
	static boolean[] isSelected;
	static int N =4;
	
	
	public static void main(String[] args) {
		numbers = new int[N];
		isSelected = new boolean[N+1];
		permutation(0);
		
	}
	
	static void permutation(int cnt) {
		if(cnt == N) {
			System.out.println(Arrays.toString(numbers));
		}
		
		for(int i=1; i <= N; i++) {
			if(isSelected[i]) continue;
			numbers[cnt] = i; 
			isSelected[i] = true;
			permutation(cnt+1);
			isSelected[i] = false;
		}
	}
}
```  
순열은 조합이 아니기에 순서에 따라 다른 값이 들어올 수 있다.       
즉, 3이 가장 첫번째 인덱스로 들어올 수 있다는 것이다.            
그렇기 때문에, 반복문을 이용할 때, 처음부터 끝까지 탐색을 계속 진행해야 한다.        
이 중에, `이미 선택한 적이 있다면?`이라는 조건을 붙여넣어서 중복을 피하도록 하면된다.  

### 중복있는 순열

```java
package com.ssafy.exhaustive;

import java.util.Arrays;

public class PermutationTest {
	static int[] numbers;
	static int N =4;
	
	
	public static void main(String[] args) {
		numbers = new int[N];
		permutation(0);		
	}
	
	static void permutation(int cnt) {
		if(cnt == N) {
			System.out.println(Arrays.toString(numbers));
		}
		
		for(int i=1; i <= N; i++) {
			numbers[cnt] = i; 
			permutation(cnt+1);
		}
	}
}
```   
중복이 없는 순열은 앞선 중복이 있는 순열보다 간단하다.          
중복 조건을 검사하는 배열과 로직을 전부 제거하면 된다.                  
이해가 어렵다면 로직을 한 번 따라가보기를 바란다.              
     
Flat 하게 생각하자면,      
첫번째 인덱스의 값은 1부터n까지 바뀐다.    
2번재 인덱스도 마찬가지로 1부터n까지 바뀐다.    
3번재, 4번째... n번째도 마찬가지이다.       
   
## c++의 nextPermutation() Java에서 구현해보기     
재귀를 이용한 방법 말고도, 반복문을 이용해서 순열을 구할 수 있다.
이 경우, 주로 `do-while` 구문과 함께 이용한다.          
       
재귀 같은 경우는 `기저 조건`일 때부터 이제 값을 구하기 위한 로직을 처리하지만,     
`nextPermutation()`같은 경우는 `do{}`에서 값을 구하기 위한 로직을 처리한다.     
    
```java
private static boolean nextPermutation(int[] list) {
	int i = list.length - 1;
	int j = list.length - 1;
	
	/** 1. 꼭대기 찾기 **/
	while(i > 0 && list[i-1] >= list[i]) --i;
	if(i <= 0) return false;	// 꼭대기가 0번째 인덱스라면 마지막순열
			
        /** 2. j값 찾기 **/
	while(list[i-1] > list[j]) --j;
	
	/** 3. swap 하기 **/
	int tmp = list[i - 1];
	list[i - 1] = list[j];
	list[j] = tmp;
	
    	/** 4. 순서 정해주기 **/
	j = list.length - 1;
	for(; i < j; ++i, --j) {
		swap(i,j);
	}
	return true;
}
```

## 정리
모든 순열의 시간복잡도는 O(n!)를 따르고있다.       
시간복잡도가 확실해서 그런지 순열문제는 크게 두가지 부류로 나눌 수있다.      
단순히 순열만을 구해 문제를 풀때는 비교적 실행시간이 빠른 next_permutation을 이용한 풀이가 좋다.     
반대로 순열을 구하는 도중에 가지치기가 필요하다던지 추가적인 조건이 들어간다면 방문처리를 이용한 순열을 이용해보자.    
       
[참고](https://velog.io/@junhok82/Java%EB%A1%9C-%EC%88%9C%EC%97%B4Permutation-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)    
        
## 순열이랑 조합이 헷갈린다면?     
나열된 순서가 다른데 의미가 있다면? 순열      
나열된 순서가 다른데 의미가 없다면? 조합           
    
* 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다. (TSP-외판원 순회)        
    
* N개의 요소들에 대해서 n! 개의 순열들이 존재한다.  
  * 12! = 479.001.600     
  * 10까지가 순열을 사용할 수 있는 제한의 최대 범위라고 생각하자           
