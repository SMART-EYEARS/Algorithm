# 순열 
> nPr      
   
순열이란 나열된 배열중 몇 개의 수를 뽑지만, 그 순서도에 따라 의미가 다르다.   
   
예시로 들자면, 123이라는 숫자가 있다.   

* 1, 2, 3
* 1, 3, 2
* 2, 1, 3
* 2, 3, 1
* 3, 1, 2
* 3, 2, 1
   
위 수들은 중복해서 조합되지만, 그 순서가 다르다.    
그렇기 때문에 서로 다른 경우의 수로 취급을 하고 이러한 방법을 순열이라 말한다.   
   
# 순열 경우의 수 구하기     
우선 순열에 대한 공식(점화식)을 한번 살펴보자      
```java
nPr = n * (n-1) *  ... * (n-r+1)
```
순열은 `n` 부터 시작해서 `r`의 갯수만큼 **내려가면서 곱**해주는 형식이다.       
팩토리얼과 비슷하지만, 팩토리얼처럼 곱셈이 내려가지만 `r`만큼만 내려간다 생각하면 된다.    
  
예를 들어 `3P2`라고 가정한다면 `(3 * 2)`의 값이 나온다.   
실생활로 예를 들어 그럼 `25`명이 있는 반에서 `4`명 뽑는다면?  
`25 * 24 * 23 * 22`의 결과값으로 `303,600` 이라는 값이 나온다.            
    
```java   
nPr = n * (n-1) *  ... * (n-n+1)  
```  
그렇기 때문에 만약, r이 n이랑 같다면 `n!` 팩토리얼이라는 값이 나온다.      
              
# 순열이 이루어진 배열의 값 구하기       
사실, 대부분의 순열 문제는 우선 이 순열이 이루어진 배열의 값을 이용해야한다.    
다시 한번 말한다. **순열이 이루어진 배열을 활용해서 답을 도출해야한다.**      
순열이 이루어진 배열을 구했다해서 바로 답이 나오지는 않는다.       
그렇기 때문에 우리는 이 준비단계? 부터 완벽히 마스터해야 문제를 풀 수 있는 수준이 된다.     
  
배열을 만드는 방식은 여러가지가 존재한다.  
그 중에서 반복문을 사용해서 간단히 만들 수 있는 방법에 대해서 먼저 알아보도록 한다.   
  
## 재귀를 이용한 순열 배열 구하기  
### 중복 없는 순열
**케이스**   
```java
numbers[] : 순열 저장 배열 
isSelected[] : 인덱스에 해당하는 숫자가 사용 중인지 저장하는 배열  
perm(cnt) // cnt : 현재까지 뽑은 순열 수의 개수  
    if cnt == 3
        순열 생성 완료 
	return;
    else
        for i from 1 to 3
            if isSelected[i] == true -> continue;
            numbers[cnt] <- i
            isSelected[i] = true
            perm(cnt+1)
            isSelected[i] = false
        end_for
            
// 사실 numbers 도 초기화 해야하는데 반복 돌면서 덮어 씌워진다.            
// 여기서 중요한 것은 원소의 갯수 즉, 인덱스의 번호가 바뀌는게 중요하다
// 그렇기에 cnt+1의 작업을 한다.   
```
    
**실제 구현**   
```java
package com.ssafy.exhaustive;

import java.util.Arrays;

public class PermutationTest {
	static int[] numbers;
	static boolean[] isSelected;
	static int N =4;
	
	
	public static void main(String[] args) {
		numbers = new int[N];
		isSelected = new boolean[N+1];
		permutation(0);
	}
	
	static void permutation(int cnt) {
		if(cnt == N) {
			System.out.println(Arrays.toString(numbers));
			return;
		}
		
		for(int i=1; i <= N; i++) {
			if(isSelected[i]) continue;
			numbers[cnt] = i; 
			isSelected[i] = true;
			permutation(cnt+1);
			isSelected[i] = false;
		}
	}
}
```  
순열은 조합이 아니기에 순서에 따라 다른 값이 들어올 수 있다.       
즉, 3이 가장 첫번째 인덱스로 들어올 수 있다는 것이다.            
그렇기 때문에, 반복문을 이용할 때, 처음부터 끝까지 탐색을 계속 진행해야 한다.        
이 중에, `이미 선택한 적이 있다면?`이라는 조건을 붙여넣어서 중복을 피하도록 하면된다.  

### 중복있는 순열

```java
package com.ssafy.exhaustive;

import java.util.Arrays;

public class PermutationTest {
	static int[] numbers;
	static int N =4;
	
	
	public static void main(String[] args) {
		numbers = new int[N];
		permutation(0);		
	}
	
	static void permutation(int cnt) {
		if(cnt == N) {
			System.out.println(Arrays.toString(numbers));
			return;
		}
		
		for(int i=1; i <= N; i++) {
			numbers[cnt] = i; 
			permutation(cnt+1);
		}
	}
}
```   
중복이 없는 순열은 앞선 중복이 있는 순열보다 간단하다.          
중복 조건을 검사하는 배열과 로직을 전부 제거하면 된다.                  
이해가 어렵다면 로직을 한 번 따라가보기를 바란다.              
     
Flat 하게 생각하자면,      
첫번째 인덱스의 값은 1부터n까지 바뀐다.    
2번재 인덱스도 마찬가지로 1부터n까지 바뀐다.    
3번재, 4번째... n번째도 마찬가지이다.       
   
## c++의 nextPermutation() Java에서 구현해보기     
재귀를 이용한 방법 말고도, 반복문을 이용해서 순열을 구할 수 있다.
이 경우, 주로 `do-while` 구문과 함께 이용한다.          
       
재귀 같은 경우는 `기저 조건`일 때부터 이제 값을 구하기 위한 로직을 처리하지만,     
`nextPermutation()`같은 경우는 `do{}`에서 값을 구하기 위한 로직을 처리한다.     
    
```java
private static boolean nextPermutation(int[] list) {
	int i = list.length - 1;
	int j = list.length - 1;
	
	/** 1. 꼭대기 찾기 **/
	while(i > 0 && list[i-1] >= list[i]) --i;
	if(i <= 0) return false;	// 꼭대기가 0번째 인덱스라면 마지막순열
			
        /** 2. j값 찾기 **/
	while(list[i-1] > list[j]) --j;
	
	/** 3. swap 하기 **/
	int tmp = list[i - 1];
	list[i - 1] = list[j];
	list[j] = tmp;
	
    	/** 4. 이후 숫자들을 오름차순으로 바꾸기 **/
	j = list.length - 1;
	for(; i < j; ++i, --j) {
		swap(i,j);
	}
	return true;
}
```
**해석**  
1. `i`와 `j`는 마지막 인덱스부터 시작한다.   
2. `i`는 자기 **자신보다 작은 수가 나올 때까지 왼쪽으로 이동**한다.   
3. 만약 자기자신보다 작은 수가 없다면, 즉 현재 배열상태가 내림차순이라면 종료한다.   
4. `j`는 **`i-1`보다 큰 수가 나올 때 까지 j를 왼쪽으로 이동**한다.            
5. 이제 swap을 한건데 중요한점은 i가 아닌 `i-1`을 swap 한다.          
6. 이후 swap된 값 이후의 값들도 swap을 진행해서 값을 정렬시켜준다.         
7. 중간 구역은 내림차순으로 정렬 되었을테니 이를 오름차순으로 바꾸기 위해서 swap을 하는 것이다.     
  
**43521 기준으로 예시를 들어보면 아래와 같다.**       
      
* i는 5에서 멈춤 (인덱스 3)    
* j는 5에서 멈춤 (3 > 5, 인덱스 3)    
* i-1을 스왑하므로 3이랑 5 스왑    
* 45321 인데 오름차순으로 정렬해야함    
* 순열의 특성상, swap 이후의 값들은 이미 내림차순으로 정렬됨  
* 버블정렬을 이용하면 내림차순은 오름차순으로 바뀐다는 특성을 이용함     
* 45123이 된다.        
   
## 반복문 없이 재귀만 사용해서 중복 없는 순열 구하기     
필자가 가장 많이 사용하는 방법이다.   
이 같은 방법은 주로, **`사용하는` 경우**, **`사용하지 않는` 경우**로 나눠질 때 사용한다.    

```java

```


## 비트 마스킹을 통한 순열 생성
```
nPn
```
**기존 방식**
```java
numbers[] : 순열 저장 배열 
isSelected[] : 인덱스에 해당하는 숫자가 사용 중인지 저장하는 배열  
perm(cnt) // cnt : 현재까지 뽑은 순열 수의 개수  
    if cnt == 3
        순열 생성 완료 
	return;
    else
        for i from 1 to 3
            if isSelected[i] == true -> continue;
            numbers[cnt] <- i
            isSelected[i] = true
            perm(cnt+1)
            isSelected[i] = false
        end_for
end perm	
```
   
**비트마스킹 방식**
```
input[] 순열 저장
numbers[] 순열 저장 배열  

perm(cnt, flag) // cnt : 현재까지 뽑은 순열 원소의 개수, flag : 선택된 원소에 대한 비트정보를 표현하는 정수 -> 즉 현재 왔던 경로들에 대한 비트를 가짐     
if cnt == n
    순열 생성 완료  
else
    for i form 0 to N-1
        if(flag & 1 << i) != 0 then continue; // 1이 있으면 이미 도착했다는 것이다.   
        numbers[cnt] <- input[i]
        perm(cnt+1, flag | 1 << i); // |을 하면 그만큼을 더한 것이다.  
    end for 
end perm    
```
* 비트를 이용해 중복체크, 방문했다는 처리도 함
* 배열을 안 만들어도 되니까, 인덱스 찾는 연산과 메모리적으로 효율이 좋아졌다.    

## 잠깐 알아두고 갈 비트 연산 상식 
  
|연산자|연산자의 기능|
|&|논리곱<br>비트 단위로 AND 연산을 한다.<br>num1 & num2<br>num2에 내용이 num1에 포함되었는지 확인한다.<br>주로 이미 방문했는가를 판단한다.|    
|`세로`|논리합<br>비트단위로 OR 연산을 한다<br>num1 | num2<br>num1과 num2를 합친다<br>주로 방문했는지 &로 검증하고 방문하지 않았다면 방문했다 처리한다.|    
|^|비트 단위로 XOR 연산을 한다.(같으면0, 다르면1)|
|~|단한 연산자로서 피 연산자의 모든 비트를 반전시킨다.|
|<<|피연산자의 비트 열을 왼쪽으로 이동시킨다.|
|>>|피연산자의 비트 열을 오른쪽으로 이동시킨다. 0으로 채운다.|   
|>>>|피연산자의 비트 열을 오른쪽으로 이동시키는데 부호도 같이 채운다.|

```java
value << n
```
* value를 n비트 만큼 왼쪽으로 shift   
* 왼쪽으로 밀어내고 남는 오른쪽 자리는 0으로 채움 
* 10 << 2 -> 20

이동 전 
|0|0|0|0|1|0|1|0|
|-|-|-|-|-|-|-|-|

이동 후    
|0|0|0|1|0|1|0|0|
|-|-|-|-|-|-|-|-|

* 1 << 1

이동 전 
|0|0|0|0|0|0|0|1|
|-|-|-|-|-|-|-|-|

이동 후    
|0|0|0|0|0|0|1|0|
|-|-|-|-|-|-|-|-|


우리는 대부분 위와 같은 형식으로 많이 사용할 것ㅇ디ㅏ.


```java
value1 & valu2
```
* value1 과 value2를 연산   
* 각 비트열을 비교하여 두 비트 모두 1이면  1, 아니면 0으로 처리   
* 내가 원하는 그 비트자리만 확인하겠다는 뜻이다.
* 주로, 여기를 방문했냐? 안했냐로 사용한다.  
* 그렇기 때문에 `1 << i`를 사용하여 여기를 방문했는지 확인한다. 
* 참고로 비트는 배열로 true/false 하려 했는데 범위가 너무 커서 배열을 만들지 못할 때 사용한다.    


* 10 & 2

**10**
|0|0|0|0|1|0|1|0|
|-|-|-|-|-|-|-|-|

**2**
|0|0|0|0|0|0|1|0|
|-|-|-|-|-|-|-|-|

**결과** 
|0|0|0|0|0|0|1|0|
|-|-|-|-|-|-|-|-|

* 정리하자면 아래와 같다.   


**방문한적이 있다**
```
값 & (1 << i)) == (1 << i) // 방문한적이 있다.   
```

**방문한적이 없다.**
```
값 & (1 << i)) == 0 // 방문한적이 없다.   
```

* 10 | 2
* value1 과 value2를 `|` 연산   
* 각 비트열을 비교하여 두 비트중 하나라도 1이면  1, 아니면 0으로 처리       
* 내가 원하는 그 비트자리를 1로 바꾼다, 지금 방문했다라고 표현할 때 사용한다.    
* 그렇기 때문에 `1 << i`를 사용하여 여기를 방문했는지 확인하고 0이면 `|`로 방문했다 처리한다.      

**10**
|0|0|0|0|1|0|1|0|
|-|-|-|-|-|-|-|-|

**2**
|0|0|0|0|0|0|1|0|
|-|-|-|-|-|-|-|-|

**결과** 
|0|0|0|0|1|0|1|0|
|-|-|-|-|-|-|-|-|

* 정리하자면 아래와 같다.   

**첫 번째 방법**
```
if(값 & (1 << i)) == 0) {
    값 | (1 << i) // 여기를 방문했다. 
}
```

**두 번째 방법**
```
if(값 & (1 << i)) == (1 << i)) continue;
값 | (1 << i) // 여기를 방문했다. 

또는 
if(값 & (1 << i)) != 0) continue;
값 | (1 << i) // 여기를 방문했다. 

```

____

```java
    public static void main(String[] args) throws IOException {
        int k = 0xa5;   // 1010 0101
        System.out.println(k & 1);       // 1    2의 0승
        System.out.println((k & 1 << 1) + "//" + Integer.toBinaryString(k & 1 << 1)); // 0    2의 2승
        System.out.println((k & 1 << 2) + "//" + Integer.toBinaryString(k & 1 << 2)); // 1   2의 3승
        System.out.println((k & 1 << 3) + "//" + Integer.toBinaryString(k & 1 << 3)); // 0    2의 3승
        System.out.println((k & 1 << 4) + "//" + Integer.toBinaryString(k & 1 << 4)); // 0    2의 4승
        System.out.println((k & 1 << 5) + "//" + Integer.toBinaryString(k & 1 << 5)); // 1    2의 5승
        System.out.println((k & 1 << 6) + "//" + Integer.toBinaryString(k & 1 << 6)); // 0    2의 6승
        System.out.println((k & 1 << 7) + "//" + Integer.toBinaryString(k & 1 << 7));; // 1    2의 7승
    }
/* 결과
1
0//0
4//100
0//0
0//0
32//100000
0//0
128//10000000
*/  
```
1은 이미 사용중  
0은 사용하지 않음   
      
32비트의 정수를 사용한다면?          
32개의 flag를 만드는 것이다.        
`boolean [] flag`  == `int flag=0` 와 똑같다.     







## 정리
모든 순열의 시간복잡도는 O(n!)를 따르고있다.       
시간복잡도가 확실해서 그런지 순열문제는 크게 두가지 부류로 나눌 수있다.      
단순히 순열만을 구해 문제를 풀때는 비교적 실행시간이 빠른 next_permutation을 이용한 풀이가 좋다.     
반대로 순열을 구하는 도중에 가지치기가 필요하다던지 추가적인 조건이 들어간다면 방문처리를 이용한 순열을 이용해보자.    
       
[참고](https://velog.io/@junhok82/Java%EB%A1%9C-%EC%88%9C%EC%97%B4Permutation-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)    


## 순열이랑 조합이 헷갈린다면?     
나열된 순서가 다른데 의미가 있다면? 순열      
나열된 순서가 다른데 의미가 없다면? 조합           
    
* 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련 있다. (TSP-외판원 순회)        
    
* N개의 요소들에 대해서 n! 개의 순열들이 존재한다.  
  * 12! = 479.001.600     
  * 10까지가 순열을 사용할 수 있는 제한의 최대 범위라고 생각하자           


# 문제 
## 기초 
[1. N과M](https://www.acmicpc.net/problem/15649)
