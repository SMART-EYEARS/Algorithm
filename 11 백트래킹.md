## N-Queen   
`n x n` 서양 장기판에서 배치한 Queen들이 서로 위협하지 않도록 n 개의 Queen을 배치하는 문제  
  
* 어떤 두 Queen도 서로를 위협하지 않아야한다.     
* Queen을 배치한 n개의 위치          

무식하게 풀기   
* Q1 놓고
* Q2 놓고
* Q3 넣고 
* Qn 넣기  

* 퇴각 검색 (뒤로 물러나다)    
* 모든 조합을 시도해서 문제의 해를 찾는다.(우리가 아는 조합이 아니다.)   
* 즉, 가능한 **모든 시도를 조합하는 것이다.**, 여러 대상의 재귀를 진행하면서 최적의 값 찾기       
* 해를 얻을 때 가지 모든 가능성을 시도한다.  
* 모든 가능성은 하나의 트리처럼 구성할 수 있으며, 가지(선택)중에 해결책이 있다.  
* 여러 가지들(선택지들)이 존재하는 상황에서 하나의 가지를 선택한다.  
* 선택이 이루어지면 새로운 선택지들의 새로운 집합이 생성된다.   
* 이런 선택을 반복하면서 최종 상태에 도달한다.   
* 보통 재귀함수로 구현한다.      
* 상태 공간 트리로 구현하고 이를 탐색한다.  
* 트리를 탐색하는 것이기 때문에 DFS,BFS를 사용하지만 주로 DFS를 사용한다       
      
가능성을 시도해보고, 해가 없으면? 다시 뒤로 돌아간다.      
뒤로 돌아가서 다시 검색한다.   
여기서 할 거 다했는데 답이 없어요 -> 뒤로 돌아가서 다음칸을 시도한다.      

    
    
난 좀 헷갈리는데..    
**백 트래킹은 분할 정복을 이용한 완전 검색(Exhaustive Search)기법**      
어떤 경우에는 문제를 푸는 최선의 알고리즘이 모든 경우의 수를 다 살펴보는 것     
     
[이분께서 정말 잘 설명해주셨다.](https://gamedevlog.tistory.com/49)    
[싸피출신](https://94incheon.github.io/algorithm/Backtracking/)

## 당첨 리프 노드 찾기  
* 루트에서 갈 수 있는 노드를 선택한다.   
* 꽝 노드까지 도달하면 최근의 선택으로 되돌아와서 다시 시작한다.   
* 더 이상 선택지가 없다면, 이전의 선택지로 돌아가서 다른 선택을 한다.   
* 루트까지 돌아갔을 경우 더 이상 선택지가 없다면 찾는 답은 없다.   


## 8-Queen 문제  
퀸 8개의 크기 8의 체스판 안에 서롤 공격할 수 없도록, 배치하는 모든 경우를 구하는 문제   

* 후보 해의 수 : 64C8 이므로, 44억개의 후보   
* 실제 해의 수 : 이중에서 실재 해는 92개뿐  
* 즉, 44억개 넘는 후보 해의 수 속에서 92개를 최대한 효율적으로 찾아내는 것이 관건   

루트 노드에서 리프노드까지 경로는 해답후보가 되는데,   
완전 탐색을 하여 그 해답후보중에서 해답을 찾을 수 있다.  
  
그러나 이 방법을 사용하면 해답이 될 가능성이 전혀 없는 노드의 후손들도 모두 검색해야 하므로 비효율적이다.  

* 모든 후보 검사? : NO
* 백트래킹 기법
  * 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 간다. (아! 중간 탈출기가 있구나)   
  * 유망하다 : 어떤 노드를 방문하였을 때, 그 노드를 포함한 경로가 해답이 될 수 있으면 유망하다고 한다.  
  * 가지치기 : 유망하지 않은 노드가 포함된 경로는 더이상 고려하지 않는다.     
      
Nqueen은 같은 행, 같은 열, 대각선 확인한다.           
스도쿠도 마찬가지겠네!, 스도쿠는 여기서 9칸 다 비교도 들어가겠다.      

### 백트래킹 절차  
1. 상태공간 트리의 깊이 우선 탐색을 시작
2. 각 노드가 유망한지를 점검한다.  
3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 다른 노드의 검색을 계속한다.     

```java
backtrack(node v) 
    IF promising(v) == flase then return    // 조건에 맞지 않는다면 -> 조건은 여러개다 (퀸을 놓을 수 있는지, 최대값이 나온 경우)       
    IF there is a solution at v             // 정답이라면 -> 마지막까지 왔다면, 최소갑이면  
        write the solution 
    ELSE
        FOR each child u of v               // 다음 작업을 위해 다음 노드로 이동 조합과 비슷한 방식
            backtrack(r)   

```

```java
class BackTracking {
	static int ans;  
	static int N;  
	
	static int[] col;
	

	 //현재 퀸이 어느위치에 있는지 위치값이 있어야 된다.      
	    
	// 같은 행에는 놓지 않는 방식으로 풀거다
	// 즉, 현재 퀸의 열 위치만 기억할 수 있게 할 것이다. 
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		N = scanner.nextInt();
		
		col = new int[N+1];

		setQueen(0);				// 코드 스타일 마다 다름 
		System.out.println(ans);
	}
	
	public static void setQueen(int rowNo) {
		
		// 탈출 , 가능하지 않다면
		if(!isAvailable(rowNo)) {
			return;			// 바로 탈출 
		}
		
		if(rowNo == N) { // 끝까지 왔다면 
			ans++;
			return;		// 일단 1회 완료  
		}
		
		// 자식노드의 가지를 파생  
		for(int i=1; i <= N; i++) {
			col[rowNo+1] = i;			 // 자식노드를 일단 i로 할당해봄 
			setQueen(rowNo+1);			// 그리고 일단 돌려본다.  
		}
		
		
	}

	private static boolean isAvailable(int rowNo) {
		// 가로세로 대각선을 해야하지만, 가로는 rowNo이기에 검사 안해도 된다.    
		
		// 대각선 공식 -> (현재.x - 다른.x) == (현재.y - 다른.y) -> 왜? 1,-1의 조합이니까   
		for(int i=1; i < rowNo; i++) { // 첫번재 퀸부터 직전 퀸
			// 퀸이 서로 위협적인 위치면 false
			if(col[rowNo] == col[i] || Math.abs(col[rowNo]-col[i]) == rowNo - i) return false;
			// 형재 퀸의 행들 빼기, 열 빼기 -> 11 13 22 31 33 -> 22를 기준으로 모든 계산 값은 11이라는 값이 나온다.,  
		}
		
		return true;
	}

}
```

## 백트래킹과 완전 탐색 DFS과의 차이      
* 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄인다.   
* 완전탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단한다.  
* 완전탐색을 가하기에는 경우의 수가 너무나 많다.     
* 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수함수시간을 요하므로 처리 불가능할 수 있다.     
    
메모이제이션은 그 길에 대한 값을 가진 것이지만        
백트래킹은 그 길 자체를 가지 말라고 말하는 것이다. 이를 가지치기라고 말한다.   


