## N-Queen   
`n x n` 서양 장기판에서 배치한 Queen들이 서로 위협하지 않도록 n 개의 Queen을 배치하는 문제  
  
* 어떤 두 Queen도 서로를 위협하지 않아야한다.     
* Queen을 배치한 n개의 위치          

무식하게 풀기   
* Q1 놓고
* Q2 놓고
* Q3 넣고 
* Qn 넣기  

* 퇴각 검색 (뒤로 물러나다)    
* 모든 조합을 시도해서 문제의 해를 찾는다.(우리가 아는 조합이 아니다.)   
* 즉, 가능한 **모든 시도를 조합하는 것이다.**, 여러 대상의 재귀를 진행하면서 최적의 값 찾기       
* 해를 얻을 때 가지 모든 가능성을 시도한다.  
* 모든 가능성은 하나의 트리처럼 구성할 수 있으며, 가지(선택)중에 해결책이 있다.  
* 여러 가지들(선택지들)이 존재하는 상황에서 하나의 가지를 선택한다.  
* 선택이 이루어지면 새로운 선택지들의 새로운 집합이 생성된다.   
* 이런 선택을 반복하면서 최종 상태에 도달한다.   
* 보통 재귀함수로 구현한다.      
* 상태 공간 트리로 구현하고 이를 탐색한다.  
* 트리를 탐색하는 것이기 때문에 DFS,BFS를 사용하지만 주로 DFS를 사용한다       
      
가능성을 시도해보고, 해가 없으면? 다시 뒤로 돌아간다.      
뒤로 돌아가서 다시 검색한다.   
여기서 할 거 다했는데 답이 없어요 -> 뒤로 돌아가서 다음칸을 시도한다.      

    
    
난 좀 헷갈리는데..    
**백 트래킹은 분할 정복을 이용한 완전 검색(Exhaustive Search)기법**      
어떤 경우에는 문제를 푸는 최선의 알고리즘이 모든 경우의 수를 다 살펴보는 것     
     
[이분께서 정말 잘 설명해주셨다.](https://gamedevlog.tistory.com/49)    
[싸피출신](https://94incheon.github.io/algorithm/Backtracking/)

## 당첨 리프 노드 찾기  
* 루트에서 갈 수 있는 노드를 선택한다.   
* 꽝 노드까지 도달하면 최근의 선택으로 되돌아와서 다시 시작한다.   
* 더 이상 선택지가 없다면, 이전의 선택지로 돌아가서 다른 선택을 한다.   
* 루트까지 돌아갔을 경우 더 이상 선택지가 없다면 찾는 답은 없다.   


## 8-Queen 문제  
퀸 8개의 크기 8의 체스판 안에 서롤 공격할 수 없도록, 배치하는 모든 경우를 구하는 문제   

* 후보 해의 수 : 64C8 이므로, 44억개의 후보   
* 실제 해의 수 : 이중에서 실재 해는 92개뿐  
* 즉, 44억개 넘는 후보 해의 수 속에서 92개를 최대한 효율적으로 찾아내는 것이 관건   

루트 노드에서 리프노드까지 경로는 해답후보가 되는데,   
완전 탐색을 하여 그 해답후보중에서 해답을 찾을 수 있다.  
  
그러나 이 방법을 사용하면 해답이 될 가능성이 전혀 없는 노드의 후손들도 모두 검색해야 하므로 비효율적이다.  

* 모든 후보 검사? : NO
* 백트래킹 기법
  * 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 간다. (아! 중간 탈출기가 있구나)   
  * 유망하다 : 어떤 노드를 방문하였을 때, 그 노드를 포함한 경로가 해답이 될 수 있으면 유망하다고 한다.  
  * 가지치기 : 유망하지 않은 노드가 포함된 경로는 더이상 고려하지 않는다.     
      
Nqueen은 같은 행, 같은 열, 대각선 확인한다.           
스도쿠도 마찬가지겠네!, 스도쿠는 여기서 9칸 다 비교도 들어가겠다.      

### 백트래킹 절차  
1. 상태공간 트리의 깊이 우선 탐색을 시작
2. 각 노드가 유망한지를 점검한다.  
3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 다른 노드의 검색을 계속한다.     

```java
backtrack(node v) 
    IF promising(v) == flase then return    // 조건에 맞지 않는다면 -> 조건은 여러개다 (퀸을 놓을 수 있는지, 최대값이 나온 경우)       
    IF there is a solution at v             // 정답이라면 -> 마지막까지 왔다면, 최소갑이면  
        write the solution 
    ELSE
        FOR each child u of v               // 다음 작업을 위해 다음 노드로 이동 조합과 비슷한 방식
            backtrack(r)   

```

```java
class BackTracking {
	static int ans;  
	static int N;  
	
	static int[] col;
	

	 //현재 퀸이 어느위치에 있는지 위치값이 있어야 된다.      
	    
	// 같은 행에는 놓지 않는 방식으로 풀거다
	// 즉, 현재 퀸의 열 위치만 기억할 수 있게 할 것이다. 
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		N = scanner.nextInt();
		
		col = new int[N+1];

		setQueen(0);				// 코드 스타일 마다 다름 
		System.out.println(ans);
	}
	
	public static void setQueen(int rowNo) {
		
		// 탈출 , 가능하지 않다면
		if(!isAvailable(rowNo)) {
			return;			// 바로 탈출 
		}
		
		if(rowNo == N) { // 끝까지 왔다면 
			ans++;
			return;		// 일단 1회 완료  
		}
		
		// 자식노드의 가지를 파생  
		for(int i=1; i <= N; i++) {
			col[rowNo+1] = i;			 // 자식노드를 일단 i로 할당해봄 
			setQueen(rowNo+1);			// 그리고 일단 돌려본다.  
		}
		
		
	}

	private static boolean isAvailable(int rowNo) {
		// 가로세로 대각선을 해야하지만, 가로는 rowNo이기에 검사 안해도 된다.    
		
		// 대각선 공식 -> (현재.x - 다른.x) == (현재.y - 다른.y) -> 왜? 1,-1의 조합이니까   
		for(int i=1; i < rowNo; i++) { // 첫번재 퀸부터 직전 퀸
			// 퀸이 서로 위협적인 위치면 false
			if(col[rowNo] == col[i] || Math.abs(col[rowNo]-col[i]) == rowNo - i) return false;
			// 형재 퀸의 행들 빼기, 열 빼기 -> 11 13 22 31 33 -> 22를 기준으로 모든 계산 값은 11이라는 값이 나온다.,  
		}
		
		return true;
	}

}
```

## 백트래킹과 완전 탐색 DFS과의 차이      
* 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄인다.   
* 완전탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단한다.  
* 완전탐색을 가하기에는 경우의 수가 너무나 많다.     
* 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수함수시간을 요하므로 처리 불가능할 수 있다.     
    
메모이제이션은 그 길에 대한 값을 가진 것이지만        
백트래킹은 그 길 자체를 가지 말라고 말하는 것이다. 이를 가지치기라고 말한다.   

## 상태 공간 트리(가능한 첫번째 해를 만날 때까지의 경우로 가정)   
같은 행에 퀸을 두지 않는 방식의 깊이 우선 탐색 vs 백트래킹   
  
* 같은 행에 퀸을 두지 않는 방식의 깊이 우선 탐색 : 155 
* 백트래킹 : 27    

# 정리
백트래킹은 모든 가능한 경우의 수 중에서 특정한 조건을 만족하는 경우만 살펴보는 것  
답이 될 만한지 판단하고 그렇지 않으면 그 부분까지 탐색하는 것을 하지 않고 가지치기 하는 것  
주로 문제 풀이에서는 DFS로 모든 경우의 수를 탐색하는 과정에서, 조건으로 답이 절대로 될 수 없는 상황을 정의하여 체크하고,   
그러한 상황일 경우에는 탐색을 중지시킨 뒤 그 이전으로 돌아가서 다시 다른 겨웅를 탐색하게끔 구현할 수 있다.   

### 부분 집합의 합 문제 
유한개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 몇번이나 있는지를 알아내는 문제   
예를 들어 `{-7 -3 -2 5 8}`라는 집합이 있을 때, `{-3 -2 5}`는 이 집합의 부분집합이면서  
(-3) + (-2) + 5 = 0 이므로 이 경우의 답은 참이 된다.  
완전 검색 기법으로 부분집합 합 문제를 풀기 위해서는, 우선 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 한다.   


### 부분 집합의 합 문제2   
유한개의 자연수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서  
그 집합의 원소를 모두 더한 값이 21이 되는 경우가 몇번이나 있는지를 알아내는 문제   
예를 들어, 5 21 11 16, 6 10 라는 집합이 있을때 5 6 10 는 집합의 부분집합이면서 21이므로 참이 된다  
      
`중간에 값이 넘었다면`이라는 가지를 칠 수 있는 명분이 있다.        
예를들어 난쟁이 문제도, 100을 초과하면 답이 될 수 없으니 가지를 칠 수 있다.   
리팩토링!!! 백트래킹은 일반 재귀를 리팩토링 할 수 있다.  

### 주의점 빵집문제 - 파이프  

우리들은 대부분 2차원 배열 문제 

* 시작점에서 부터 도착점의 모든 경우의 수    
* 파이프의 최소 길이 구하는 경우
* 한개의 파이프라인을 놓는데 가능한 경우의 수 

이러한 문제를 푸는 경우가 많고 헷갈릴만하다.   
      
파이프는 경로의 **갯수**를 구하는 것이지        
해당 지점에 올 수 있는 모든 경우의 갯수를 구하는 것이 아니다.           
     
우리는 가능한 파이프를 여러개 **동시에** 설치하는 것을 구하는 것이다.       
즉, 경우의 수가 아니라 **동시에** 문제를 구하는 것이다.      
하지만, 동시에라는 작업이 힘들기 때문에 순차적으로 처리한 것일 뿐이다.    

그렇다면 파이프를 놓는 순서는?    
* 첫번째 파이프를 놓는 위치에 따라 2번째 3번째 파이프가 영향을 받는다.   
* \


